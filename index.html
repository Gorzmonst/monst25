// ç”»åƒãƒã‚§ãƒƒã‚¯ï¼ˆPyodide ãƒ™ãƒ¼ã‚¹ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒãƒƒãƒãƒ³ã‚°ï¼‰
async function checkImage() {
    console.log("checkImage ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã—ãŸ"); // ãƒ‡ãƒãƒƒã‚°ç”¨
    if (!pyodideReady) {
        console.log("pyodideReady: ", pyodideReady);
        alert("Pyodide ãŒã¾ã æº–å‚™ã§ãã¦ã„ã¾ã›ã‚“ã€‚ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ã¿ã¦ãã ã•ã„ã€‚");
        return;
    }
    if (!uploadedImage) {
        console.log("uploadedImage: ", uploadedImage);
        alert("ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚");
        return;
    }
    if (!templateBytes) {
        console.log("templateBytes: ", templateBytes);
        alert("ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»åƒï¼ˆBase64ï¼‰ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ã¿ã¦ãã ã•ã„ã€‚");
        return;
    }

    try {
        const positions = await runMatching(false);
        console.log("æ¤œå‡ºã•ã‚ŒãŸä½ç½®: ", positions); // ãƒ‡ãƒãƒƒã‚°ç”¨
        // çµæœã‚’ã‚¢ãƒ©ãƒ¼ãƒˆã§ã¯ãªã displayResults ã§è¡¨ç¤º
        displayResults(positions);
    } catch (error) {
        console.error("ç”»åƒãƒã‚§ãƒƒã‚¯ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ", error);
        alert("ç”»åƒãƒã‚§ãƒƒã‚¯ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + error.message + "\nã‚¹ã‚¿ãƒƒã‚¯: " + error.stack);
    }
}

// Pyodide ãƒ™ãƒ¼ã‚¹ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒãƒƒãƒãƒ³ã‚°
async function runMatching(isInitial) {
    const threshold = parseFloat(document.getElementById("threshold").value); // é–¾å€¤ã‚’å‹•çš„ã«å–å¾—
    const imageInput = document.getElementById("imageUpload");
    const imgEl = document.getElementById("resultImage");

    if (imageInput.files.length === 0) {
        throw new Error("å¯¾è±¡ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
    }

    const imageFile = imageInput.files[0];
    const imageExt = imageFile.name.split('.').pop().toLowerCase();
    const imageName = "uploaded." + imageExt;

    const imageBytes = new Uint8Array(await imageFile.arrayBuffer());
    pyodide.FS.writeFile('template.png', templateBytes); // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»åƒï¼ˆBase64ï¼‰
    pyodide.FS.writeFile(imageName, imageBytes);

    const pythonCode = `
import cv2
import numpy as np
import base64

log = []
try:
    log.append("ğŸ”¹ template èª­ã¿è¾¼ã¿ä¸­...")
    template = cv2.imread("template.png", 0)
    if template is None:
        raise Exception("ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—")

    log.append("ğŸ”¹ å¯¾è±¡ç”»åƒ èª­ã¿è¾¼ã¿ä¸­...")
    img_color = cv2.imread("${imageName}")
    img_gray = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)

    log.append("ğŸ”¹ ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒãƒƒãƒãƒ³ã‚°å®Ÿè¡Œä¸­...")
    res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)
    log.append("ğŸ”¹ é–¾å€¤ ${threshold} ä»¥ä¸Šã‚’æŠ½å‡ºä¸­...")
    loc = np.where(res >= ${threshold})
    result = list(zip(*loc[::-1]))

    min_distance = 10
    final_result = []
    for pt in result:
        add = True
        for other_pt in final_result:
            dist = np.linalg.norm(np.array(pt) - np.array(other_pt))
            if dist < min_distance:
                add = False
                break
        if add:
            final_result.append(pt)

    final_result_sorted = sorted(final_result, key=lambda x: x[0])

    # ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»åƒã®ã‚µã‚¤ã‚ºã‚’å–å¾—
    h, w = template.shape
    log.append(f"ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”»åƒã®ã‚µã‚¤ã‚º: å¹…={w}, é«˜ã•={h}")

    # ä¸­å¿ƒåº§æ¨™ã«å¤‰æ›ã—ãŸçµæœã‚’æ ¼ç´ï¼ˆæµ®å‹•å°æ•°ç‚¹ã§è¨ˆç®—ï¼‰
    final_result_centered = [(pt[0] + w / 2.0, pt[1] + h / 2.0) for pt in final_result_sorted]

    if final_result_sorted:
        log.append("âœ… ãƒãƒƒãƒç®‡æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸï¼ˆä¸­å¿ƒåº§æ¨™ï¼‰:")
        if len(final_result_sorted) > 5:
            log.append("âš ï¸ ãƒãƒƒãƒç®‡æ‰€ãŒå¤šã™ãã¾ã™ã€‚é–¾å€¤ã‚’èª¿æ•´ã™ã‚‹ã‹ã€ç¯„å›²ã‚’ç‹­ã‚ã¦ãã ã•ã„ã€‚")
        for pt in final_result_centered:
            log.append(f"X: {pt[0]}, Y: {pt[1]}")
            pt_left_top = (int(pt[0] - w / 2.0), int(pt[1] - h / 2.0))
            pt_right_bottom = (int(pt[0] + w / 2.0), int(pt[1] + h / 2.0))
            cv2.rectangle(img_color, pt_left_top, pt_right_bottom, (0, 0, 255), 2)
            cv2.circle(img_color, (int(pt[0]), int(pt[1])), 10, (0, 255, 0), 2)
    else:
        log.append("âš ï¸ ãƒãƒƒãƒãªã—")

    cv2.imwrite("result.png", img_color)

    with open("result.png", "rb") as f:
        img_bytes = f.read()
    img_base64 = base64.b64encode(img_bytes).decode("utf-8")

except Exception as e:
    log.append("âŒ ã‚¨ãƒ©ãƒ¼: " + str(e))
    img_base64 = ""

"\\n".join(log) + "\\n__SPLIT__\\n" + img_base64 + "\\n__SPLIT__\\n" + str(final_result_centered)
`;

    try {
        const result = await pyodide.runPythonAsync(pythonCode);
        const [logText, imgBase64, positionsStr] = result.split("__SPLIT__");
        console.log("Pyodide ãƒ­ã‚°: ", logText);

        // çµæœç”»åƒã‚’è¡¨ç¤º
        if (imgBase64) {
            imgEl.src = "data:image/png;base64," + imgBase64;
        } else {
            imgEl.src = "";
        }

        // ä½ç½®æƒ…å ±ã‚’ãƒ‘ãƒ¼ã‚¹ï¼ˆä¸­å¿ƒåº§æ¨™ã¨ã—ã¦å—ã‘å–ã‚‹ï¼‰
        const positions = JSON.parse(positionsStr);
        return positions;
    } catch (err) {
        console.error("Pyodide å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: ", err);
        throw new Error("Pyodide å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:\n" + err);
    }
}